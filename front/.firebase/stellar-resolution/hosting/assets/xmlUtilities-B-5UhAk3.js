const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/densifyOperator-CEhH7LYN.js","assets/index-BCRx-hwS.js","assets/index-BR8bGno3.css","assets/Point2D-CXC1yv_O.js","assets/ProjectionTransformation-CoAUJI3p.js","assets/Envelope2D-C_JUGA2P.js","assets/Transformation2D-sny6HUws.js","assets/SimpleGeometryCursor-B92kdZ15.js","assets/OperatorDefinitions-DP7_WWTp.js","assets/jsonConverter-BHyufzdl.js","assets/operatorDensify-tSuNWtxY.js","assets/apiConverter-Da8xt-f2.js","assets/differenceOperator-D0FU99fK.js","assets/lengthOperator-Dzm68w-M.js"])))=>i.map(i=>d[i]);
import{ba as Be,i0 as Z,sd as Ie,bv as re,fa as se,al as C,ak as U,s as N,b1 as be,i1 as Ce,bI as we,f2 as De,r as g,m as I,h3 as _e,b as ce,fx as $e,_ as K,P as ze,hR as Me,bH as He,h1 as Je,d6 as Ne}from"./index-BCRx-hwS.js";import{g as ve,N as Ee,i as Oe,a as We,b as Se,u as Le,c as he,p as Ae,l as qe,d as Ge,j as je,f as Ve,e as fe,W as me,h as Ue,k as Qe,w as Xe,v as Ye,m as Ze,n as Ke,q as et,D as tt,z as it,B as de,t as nt,o as pe}from"./RasterJobHandlerMixin-BqSrYkTB.js";import{T as ie,j as rt,l as st,D as ke,a as at,u as ot,b as lt,h as ct,_ as ut,d as ht}from"./RasterSymbolizer-kKSN3U21.js";import{r as V}from"./datasetUtils-C--lKL1u.js";import{QueueProcessor as ft}from"./QueueProcessor-BvyYj52D.js";import{e as X,v as ae,A as ye,u as xe,f as mt,o as ne,Q as Y,s as dt,i as pt,_ as yt,V as oe}from"./rasterProjectionHelper-DhhcDsIC.js";import{g as xt}from"./pixelRangeUtils-CKdSGD5A.js";import{r as le,p as gt,T as Rt}from"./rasterFunctionHelper-CQvJL6EH.js";let It=class{constructor(t=15e3,r=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=t,this._interval=Math.min(t,r)}decreaseRefCount(t,r){const e=t+"/"+r,n=this._cachedBlocks;if(n.has(e)){const s=n.get(e);return s.refCount--,s.refCount<=0&&(n.delete(e),s.controller&&s.controller.abort()),s.refCount}return 0}getBlock(t,r){const e=t+"/"+r,n=this._cachedBlocks;if(n.has(e)){const s=n.get(e);return s.ts=Date.now(),s.refCount++,n.delete(e),n.set(e,s),s.block}return null}putBlock(t,r,e,n){const s=this._cachedBlocks,a=t+"/"+r;if(s.has(a)){const o=s.get(a);o.ts=Date.now(),o.refCount++}else s.set(a,{block:e,ts:Date.now(),refCount:1,controller:n});this._trim(),this._updateTimer()}deleteBlock(t,r){const e=this._cachedBlocks,n=t+"/"+r;e.has(n)&&e.delete(n)}updateMaxSize(t){this._size=t,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(this._timer!=null)return;const t=this._cachedBlocks;this._timer=setInterval(()=>{const r=Array.from(t),e=Date.now();for(let n=0;n<r.length&&r[n][1].ts<=e-this._duration;n++)t.delete(r[n][0]);t.size===0&&this._clearTimer()},this._interval)}_trim(){const t=this._cachedBlocks;if(this._size===-1||this._size>=t.size)return;const r=Array.from(t);for(let e=0;e<r.length-this._size;e++)t.delete(r[e][0])}_clearTimer(){this._timer!=null&&(clearInterval(this._timer),this._timer=null)}};const te=new Map,E=new It;function bt(i,t,r){const e=[];return t!=null&&e.push(`sliceId=${t}`),r!=null&&e.push(`bandIds=${r.join(",")}`),e.length?`${i}?${e.join("&")}`:i}function wt(i,t,r){var a,o;const e=te.get(i);if(!e)return t==null?E.decreaseRefCount(i,r):0;if(t==null||e[t]==null)return E.decreaseRefCount(i,r);const n=(a=e[t])==null?void 0:a.cache,s=n==null?void 0:n.get(r);if(n&&s){if(s.refCount--,s.refCount===0){n.delete(r);for(let l=0;l<e.length;l++)(o=e[l])==null||o.cache.delete(r);s.controller&&s.controller.abort()}return s.refCount}return 0}function _t(i,t,r){var s,a,o;const e=te.get(i);if(!e)return t==null?E.getBlock(i,r):null;if(t==null||e[t]==null){for(let l=0;l<e.length;l++){const c=(s=e[l])==null?void 0:s.cache.get(r);if(c)return c.refCount++,c.block}return E.getBlock(i,r)}const n=(a=e[t])==null?void 0:a.cache.get(r);if(n)return n.refCount++,n.block;for(let l=0;l<e.length;l++){if(l===t||!e[l])continue;const c=(o=e[l])==null?void 0:o.cache,u=c==null?void 0:c.get(r);if(c&&u)return u.refCount++,c.set(r,u),u.block}return null}function vt(i,t,r,e,n=null){var o;const s=te.get(i);if(!s)return void(t==null&&E.putBlock(i,r,e,n));if(t==null||s[t]==null)return void E.putBlock(i,r,e,n);const a={refCount:1,block:e,isResolved:!1,isRejected:!1,controller:n};e.then(()=>a.isResolved=!0).catch(()=>a.isRejected=!0),(o=s[t])==null||o.cache.set(r,a)}function St(i,t,r){var n;const e=te.get(i);e?t!=null&&e[t]!=null?(n=e[t])==null||n.cache.delete(r):E.deleteBlock(i,r):t==null&&E.deleteBlock(i,r)}const ge=8,kt=256;let Tt=0,v=class extends Be{constructor(){super(...arguments),this._tileFetchQueue=new ft({concurrency:32,process:(i,t)=>this._fetchRawTile(i.pyramidLevel,i.row,i.col,{...i.options,signal:t})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(i){return i!=null&&i.ioConfig&&(i={...i,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:Z.create(),...i.ioConfig}}),i}get _isGlobalWrappableSource(){const{rasterInfo:i}=this,t=X(i.spatialReference);return t!=null&&i.extent.width>=t/2}get _hasNoneOrGCSShiftTransform(){const{transform:i}=this.rasterInfo;return i==null||i.type==="gcs-shift"}set rasterJobHandler(i){var t,r;this._set("rasterJobHandler",i),V(this)&&((r=(t=this.primaryRasters)==null?void 0:t.rasters)==null||r.forEach(e=>e.rasterJobHandler=i))}get rasterId(){return this.url||"rasterId-"+Tt++}set url(i){this._set("url",Ie(i,re.getLogger(this)))}async open(i){return this._openPromise??(this._openPromise=ae().then(()=>this._open(i))),this._openPromise}async fetchTile(i,t,r,e={}){const n=e.tileInfo||this.rasterInfo.storageInfo.tileInfo,s=this.getTileExtentFromTileInfo(i,t,r,n);return e={noClip:!0,...e},this.fetchPixels(s,n.size[0],n.size[1],e)}async identify(i,t={}){var M;i=se(C,i).clone().normalize();const{multidimensionalDefinition:r,timeExtent:e}=t,{rasterInfo:n}=this,{hasMultidimensionalTranspose:s,multidimensionalInfo:a}=n;let{transposedVariableName:o}=t;const l=a!=null&&s&&(e!=null||ve(r));l&&!o&&(o=r!=null&&r.length>0?r[0].variableName??void 0:a.variables[0].name,t={...t,transposedVariableName:o}),t=this._getRequestOptionsWithSliceId(t);const{spatialReference:c,extent:u}=n,{datumTransformation:h}=t;let m=ye(i,c,h);if(!u.intersects(m))return{location:m,value:null};if(n.transform!=null){const D=n.transform.inverseTransform(m);if(!n.nativeExtent.intersects(D))return{location:D,value:null};m=D}let p=0;const y=o!=null&&a!=null&&n.hasMultidimensionalTranspose;if(V(this)){const D=this.primaryRasters.rasters[0];if(y)return D.identify(m,t);const{pixelSize:H}=n,S=3,O=H.x*S/2,W=H.y*S/2,L=new U({xmin:m.x-O,xmax:m.x+O,ymin:m.y-W,ymax:m.y+W,spatialReference:c}),P={interpolation:"nearest",multidimensionalDefinition:r,sliceId:t.sliceId},{pixelBlock:k}=await D.fetchPixels(L,S,S,P),{pixelBlock:T}=await this.fetchPixels(L,S,S,P);if(k==null)return{location:m,value:null};const F=Math.floor(S*S*.5),A=!k.mask||k.mask[F]?k.pixels.map(B=>B[F]):null;let $;return T!=null&&($=!T.mask||T.mask[F]?T.pixels.map(B=>B[F]):void 0),{location:m,value:A,processedValue:$,pyramidLevel:0}}if(!y){if(t.srcResolution)p=xe(t.srcResolution,n,this.ioConfig.sampling).pyramidLevel;else if(p=await this.computeBestPyramidLevelForLocation(i,t),p==null)return{location:m,value:null}}const x=this.identifyPixelLocation(m,p,null,y);if(x===null)return{location:m,value:null};const{row:d,col:f,rowOffset:R,colOffset:b,blockWidth:_}=x,w=await this._tileFetchQueue.push({pyramidLevel:p,row:d,col:f,options:t},{signal:t.signal});if(!((M=w==null?void 0:w.pixels)!=null&&M.length))return{location:m,value:null};const z=R*_+b;return this._processIdentifyResult(w,{srcLocation:m,position:z,pyramidLevel:p,useTransposedTile:!!y,requestSomeSlices:l,identifyOptions:t})}async fetchPixels(i,t,r,e={}){i=mt(i),e=this._getRequestOptionsWithSliceId(e);const{_hasNoneOrGCSShiftTransform:n}=this;if(e.requestRawData&&n)return this._fetchPixels(i,t,r,e);const s=X(i.spatialReference),a=ne(i);if(s==null||a===0||a===1&&this._isGlobalWrappableSource&&n)return this._fetchPixels(i,t,r,e);if(a>=3)return{extent:i,pixelBlock:null};const o=[],{xmin:l,xmax:c}=i,u=Math.round(s/(c-l)*t),h=u-Math.round((s/2-l)/(c-l)*t);let m=0;const p=[];for(let f=0;f<=a;f++){const R=new U({xmin:f===0?l:-s/2,xmax:f===a?c-s*f:s/2,ymin:i.ymin,ymax:i.ymax,spatialReference:i.spatialReference}),b=f===0?u-h:f===a?t-m:u;m+=b,p.push(b);const _=e.disableWrapAround&&f>0?null:this._fetchPixels(R,b,r,e);o.push(_)}const y=(await Promise.all(o)).map(f=>f==null?void 0:f.pixelBlock);let x=null;const d={width:t,height:r};return this.rasterJobHandler?x=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:y,srcMosaicSize:d,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:p},e)).pixelBlock:x=ie(y,d,{blockWidths:p}),{extent:i,srcExtent:Y(i,this.rasterInfo.spatialReference,e.datumTransformation),pixelBlock:x}}async fetchRawPixels(i,t,r,e={}){t={x:Math.floor(t.x),y:Math.floor(t.y)};const n=await this._fetchRawTiles(i,t,r,e),{nativeExtent:s,nativePixelSize:a,storageInfo:o}=this.rasterInfo,l=2**i,c=a.x*l,u=a.y*l,h=new U({xmin:s.xmin+c*t.x,xmax:s.xmin+c*(t.x+r.width-1),ymin:s.ymax-u*(t.y+r.height-1),ymax:s.ymax-u*t.y,spatialReference:s.spatialReference});if(!n)return{extent:h,srcExtent:h,pixelBlock:null};const{pixelBlocks:m,mosaicSize:p}=n;if(m.length===1&&m[0]!=null&&m[0].width===r.width&&m[0].height===r.height)return{extent:h,srcExtent:h,pixelBlock:n.pixelBlocks[0]};const y=i>0?o.pyramidBlockWidth:o.blockWidth,x=i>0?o.pyramidBlockHeight:o.blockHeight,d={x:t.x%y,y:t.y%x};let f;return this.rasterJobHandler?f=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:m,srcMosaicSize:p,destDimension:r,clipOffset:d,clipSize:r,coefs:null,sampleSpacing:null,interpolation:e.interpolation,alignmentInfo:null,blockWidths:null},e)).pixelBlock:f=ie(m,p,{clipOffset:d,clipSize:r}),{extent:h,srcExtent:h,pixelBlock:f}}fetchRawTile(i,t,r,e){throw new N("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(i){return Y(this.rasterInfo.extent,i)}decodePixelBlock(i,t){return!this.rasterJobHandler||t.useCanvas?rt(i,t):this.rasterJobHandler.decode({data:i,options:t})}async request(i,t,r=0){const{customFetchParameters:e}=this.ioConfig,{range:n,query:s,headers:a}=t;r=r??t.retryCount??this.ioConfig.retryCount;const o=n?{Range:`bytes=${n.from}-${n.to}`}:null;try{return await be(i,{...t,query:{...s,...e},headers:{...a,...o}})}catch(l){if(r>0)return r--,this.request(i,t,r);throw l}}getSliceIndex(i){const{multidimensionalInfo:t}=this.rasterInfo;return t==null||i==null||i.length===0?null:Ee(i,t)}getTileExtentFromTileInfo(i,t,r,e){const n=e.lodAt(i);return this.getTileExtent({x:n.resolution,y:n.resolution},t,r,e.origin,e.spatialReference,e.size)}updateTileInfo(){const{storageInfo:i,spatialReference:t,extent:r,pixelSize:e}=this.rasterInfo,{pyramidResolutions:n}=i;if(!i.tileInfo){const s=[],a=i.maximumPyramidLevel||0;let o=(e.x+e.y)/2,l=1/.0254*96*o;for(let u=0;u<=a&&(s.unshift(new Ce({level:a-u,resolution:o,scale:l})),u!==a);u++)if(n){const h=(n[u].x+n[u].y)/2;l*=h/o,o=h}else o*=2,l*=2;const c=new C({x:r.xmin,y:r.ymax,spatialReference:t});i.tileInfo=new Z({origin:c,size:[i.blockWidth,i.blockHeight],spatialReference:t,lods:s}),i.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(i,t=512,r=512,e){const{width:n,height:s,nativeExtent:a,pixelSize:o,spatialReference:l}=i,c=new C({x:a.xmin,y:a.ymax,spatialReference:l});e==null&&(e=Math.max(0,Math.round(Math.log(Math.max(n,s))/Math.LN2-8)));const u=this.computeBlockBoundary(a,512,512,{x:a.xmin,y:a.ymax},[o],e);i.storageInfo=new st({blockWidth:t,blockHeight:r,pyramidBlockWidth:t,pyramidBlockHeight:r,origin:c,firstPyramidLevel:1,maximumPyramidLevel:e,blockBoundary:u})}async computeBestPyramidLevelForLocation(i,t={}){return 0}computeBlockBoundary(i,t,r,e,n,s=0,a=2){if(n.length===1&&s>0){n=[...n];let{x:u,y:h}=n[0];for(let m=0;m<s;m++)u*=a,h*=a,n.push({x:u,y:h})}const o=[],{x:l,y:c}=e;for(let u=0;u<n.length;u++){const{x:h,y:m}=n[u];o.push({minCol:Math.floor((i.xmin-l+.1*h)/t/h),maxCol:Math.floor((i.xmax-l-.1*h)/t/h),minRow:Math.floor((c-i.ymax+.1*m)/r/m),maxRow:Math.floor((c-i.ymin-.1*m)/r/m)})}return o}getPyramidPixelSize(i){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:r,pyramidScalingFactor:e}=this.rasterInfo.storageInfo;if(i===0)return t;if(r!=null&&r.length)return r[i-1];const n=e**i;return{x:t.x*n,y:t.y*n}}identifyPixelLocation(i,t,r,e){const{spatialReference:n,nativeExtent:s,storageInfo:a}=this.rasterInfo,{maximumPyramidLevel:o,origin:l,transposeInfo:c}=a,u=e&&c!=null?c.tileSize[0]:a.blockWidth,h=e&&c!=null?c.tileSize[1]:a.blockHeight,m=ye(i,n,r);if(!s.intersects(m)||t<0||t>o)return null;const p=this.getPyramidPixelSize(t),{x:y,y:x}=p,d=(l.y-m.y)/x/h,f=(m.x-l.x)/y/u,R=Math.min(h-1,Math.floor((d-Math.floor(d))*h)),b=Math.min(u-1,Math.floor((f-Math.floor(f))*u));return{pyramidLevel:t,row:Math.floor(d),col:Math.floor(f),rowOffset:R,colOffset:b,blockWidth:u,srcLocation:m}}getTileExtent(i,t,r,e,n,s){const[a,o]=s,l=e.x+r*a*i.x,c=l+a*i.x,u=e.y-t*o*i.y,h=u-o*i.y;return new U({xmin:l,xmax:c,ymin:h,ymax:u,spatialReference:n})}getBlockWidthHeight(i){return{blockWidth:i>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:i>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(i,t,r){const e=this.rasterInfo.storageInfo.blockBoundary[i];return!e||e.maxRow<t||e.maxCol<r||e.minRow>t||e.minCol>r}updateImageSpaceRasterInfo(i){const{pixelSize:t}=i,{width:r,height:e}=i,n=we.WebMercator;i.spatialReference=n,i.extent=i.nativeExtent=new U({xmin:-.5,ymax:.5,xmax:r-.5,ymin:.5-e,spatialReference:n}),i.isPseudoSpatialReference=!0,i.transform=null,i.pixelSize=new C({x:1,y:1,spatialReference:n});const{extent:s,storageInfo:a}=i;if(a){a.origin=new C({x:s.xmin,y:s.ymax,spatialReference:n});const{pyramidResolutions:o,tileInfo:l}=a;if(o&&o.forEach(c=>{c.x/=t.x,c.y/=t.y}),l){l.origin=a.origin;const c=(i.nativePixelSize.x+i.nativePixelSize.y)/2;l.lods.forEach((u,h)=>{u.resolution=c*2**h,u.scale=96*u.resolution/.0254})}}}async _fetchPixels(i,t,r,e={}){let n=ne(i);if(n>=2)return{extent:i,pixelBlock:null};const s=this._getSourceDataInfo(i,t,r,e),{pyramidLevel:a,srcResolution:o,srcExtent:l,srcWidth:c,srcHeight:u,ul:h}=s;if(c===0||u===0)return{extent:i,srcExtent:l,pixelBlock:null};const{rasterInfo:m}=this,p=m.transform,y=(p==null?void 0:p.type)==="gcs-shift",x=X(i.spatialReference)!=null;!y&&x||(n=ne(s.srcExtent,y));const d=await this._fetchRawTiles(a,h,{width:c,height:u,wrapCount:n},e);if(!d)return{extent:i,srcExtent:l,pixelBlock:null};const f=m.storageInfo,R=a>0?f.pyramidBlockWidth:f.blockWidth,b=a>0?f.pyramidBlockHeight:f.blockHeight;let{x:_,y:w}=m.pixelSize;if(a>0){const{pyramidResolutions:J,pyramidScalingFactor:Fe}=f;if(J!=null&&J[a-1])({x:_,y:w}=J[a-1]);else{const ue=Fe**a;_*=ue,w*=ue}}const z=m.spatialReference,M=new C({x:_,y:w,spatialReference:z}),D=R===c&&b===u&&h.x%R===0&&h.y%b===0,H=new C({x:(i.xmax-i.xmin)/t,y:(i.ymax-i.ymin)/r,spatialReference:i.spatialReference}),S=!i.spatialReference.equals(z),O=z.isGeographic?1e-9:1e-4,{datumTransformation:W}=e;if(!S&&D&&d.pixelBlocks.length===1&&R===t&&b===r&&Pt(o,H,O))return{extent:i,srcExtent:l,srcTilePixelSize:M,pixelBlock:d.pixelBlocks[0]};const L=x&&X(l.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,P=e.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");P&&!this.rasterJobHandler&&await ae();const k=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:i,srcBufferExtent:d.extent,pixelSize:H.toJSON(),datumTransformation:W,rasterTransform:p,hasWrapAround:n>0||L,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:P},e):dt({projectedExtent:i,srcBufferExtent:d.extent,pixelSize:H,datumTransformation:W,rasterTransform:p,hasWrapAround:n>0||L,isAdaptive:!1,includeGCSGrid:P});let T;const F=!e.requestRawData,A={rows:k.spacing[0],cols:k.spacing[1]},$=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(a,d.extent.xmin):void 0,{pixelBlocks:B,mosaicSize:q,isPartiallyFilled:Q}=d;let G=null;if(this.rasterJobHandler)({pixelBlock:T,localNorthDirections:G}=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:B,srcMosaicSize:q,destDimension:F?{width:t,height:r}:null,coefs:F?k.coefficients:null,sampleSpacing:F?A:null,projectDirections:P,gcsGrid:P?k.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:e.interpolation,alignmentInfo:$,blockWidths:null},e));else{const J=ie(B,q,{alignmentInfo:$});T=F?ke(J,{width:t,height:r},k.coefficients,A,e.interpolation):J,P&&k.gcsGrid&&(G=at({width:t,height:r},k.gcsGrid),T=ot(T,this.rasterInfo.dataType,G))}return e.requestRawData||P?{extent:i,srcExtent:l,srcTilePixelSize:M,pixelBlock:T,transformGrid:k,localNorthDirections:G,isPartiallyFilled:Q}:{extent:i,srcExtent:l,srcTilePixelSize:M,pixelBlock:T}}async _fetchRawTiles(i,t,r,e){const{origin:n,blockBoundary:s}=this.rasterInfo.storageInfo,{blockWidth:a,blockHeight:o}=this.getBlockWidthHeight(i);let{x:l,y:c}=t,{width:u,height:h,wrapCount:m}=r;const p=this._getRasterTileAlignmentInfo(i,0);e.buffer&&(l-=e.buffer.cols,c-=e.buffer.rows,u+=2*e.buffer.cols,h+=2*e.buffer.rows);let y=0,x=0,d=0;m&&p!=null&&({worldColumnCountFromOrigin:x,originColumnOffset:d,rightPadding:y}=p,x*p.blockWidth-y>=l+u&&(y=0));const f=Math.floor(l/a),R=Math.floor(c/o),b=Math.floor((l+u+y-1)/a),_=Math.floor((c+h+y-1)/o),w=s[i];if(!w)return null;const{minRow:z,minCol:M,maxCol:D,maxRow:H}=w;if(m===0&&(_<z||b<M||R>H||f>D))return null;const S=new Array;let O=!1;const W=this.ioConfig.allowPartialFill==null?e.allowPartialFill:this.ioConfig.allowPartialFill;for(let $=R;$<=_;$++)for(let B=f;B<=b;B++){let q=B;if(!e.disableWrapAround&&m&&p!=null&&x<=B&&(q=B-x-d),$>=z&&q>=M&&H>=$&&D>=q){const Q=this._tileFetchQueue.push({pyramidLevel:i,row:$,col:q,options:e},{signal:e.signal});W?S.push(new Promise(G=>{Q.then(J=>G(J)).catch(()=>{O=!0,G(null)})})):S.push(Q)}else S.push(Promise.resolve(null))}if(S.length===0)return null;const L=await Promise.all(S),P={height:(_-R+1)*o,width:(b-f+1)*a},{spatialReference:k}=this.rasterInfo,T=this.getPyramidPixelSize(i),{x:F,y:A}=T;return{extent:new U({xmin:n.x+f*a*F,xmax:n.x+(b+1)*a*F,ymin:n.y-(_+1)*o*A,ymax:n.y-R*o*A,spatialReference:k}),pixelBlocks:L,mosaicSize:P,isPartiallyFilled:O}}_fetchRawTile(i,t,r,e){const{storageInfo:n}=this.rasterInfo,s=n.transposeInfo!=null&&!!e.transposedVariableName;if(!s){const h=n.blockBoundary[i];if(!h)return Promise.resolve(null);const{minRow:m,minCol:p,maxCol:y,maxRow:x}=h;if(t<m||r<p||t>x||r>y)return Promise.resolve(null)}const a=s?e.transposeVariableName:e.sliceId,o=this.rasterInfo.storageInfo.isBsqTile?e.bandIds:null,l=bt(this.rasterId,a,o),c=`${i}/${t}/${r}`;let u=_t(l,e.registryId,c);if(u==null){const h=new AbortController;u=this.fetchRawTile(i,t,r,{...e,signal:h.signal}),vt(l,e.registryId,c,u,h),u.catch(()=>St(l,e.registryId,c))}return e.signal&&De(e,()=>{wt(l,e.registryId,c)}),u}_computeMagDirValues(i){var l;const{bandCount:t,dataType:r}=this.rasterInfo;if(!(t===2&&r==="vector-magdir"||r==="vector-uv")||(i==null?void 0:i.length)!==2||!((l=i[0])!=null&&l.length))return null;const e=i[0].length;if(r==="vector-magdir"){const c=i[1].map(u=>(u+360)%360);return[i[0],c]}const[n,s]=i,a=[],o=[];for(let c=0;c<e;c++){const[u,h]=lt([n[c],s[c]]);a.push(u),o.push(h)}return[a,o]}_getRasterTileAlignmentInfo(i,t){return this._rasterTileAlignmentInfo==null&&(this._rasterTileAlignmentInfo=pt(this.rasterInfo)),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:{startX:t,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[i]}}_getSourceDataInfo(i,t,r,e={}){const n={datumTransformation:e.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};e.srcResolution&&(n.srcResolution=e.srcResolution,this._updateSourceDataInfo(i,n));const s=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:a,srcHeight:o,pyramidLevel:l}=n,c=a/t,u=o/r,h=l<s&&c*u>=16,m=l===s&&this._requireTooManySrcTiles(a,o,t,r);if(h||m||a===0||o===0){const p=new C({x:(i.xmax-i.xmin)/t,y:(i.ymax-i.ymin)/r,spatialReference:i.spatialReference});let y=yt(p,this.rasterInfo.spatialReference,i,n.datumTransformation);const x=!y||e.srcResolution&&y.x+y.y<e.srcResolution.x+e.srcResolution.y;if(h&&e.srcResolution&&x){const d=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(s-l+3>=d){const f=2**d;y={x:e.srcResolution.x*f,y:e.srcResolution.y*f}}}y&&(n.srcResolution=y,this._updateSourceDataInfo(i,n))}return this._requireTooManySrcTiles(n.srcWidth,n.srcHeight,t,r)&&(n.srcWidth=0,n.srcHeight=0),n}_requireTooManySrcTiles(i,t,r,e){const{tileInfo:n}=this.rasterInfo.storageInfo,s=Math.ceil(i/n.size[0])*Math.ceil(t/n.size[1]),a=i/r,o=t/e,l=Math.max(1,(r+e)/1024);return s>=kt*l||a>ge||o>ge}_updateSourceDataInfo(i,t){t.srcWidth=0,t.srcHeight=0;const{rasterInfo:r}=this,e=r.spatialReference,{srcResolution:n,datumTransformation:s}=t,{pyramidLevel:a,pyramidResolution:o,excessiveReading:l}=xe(n,r,this.ioConfig.sampling);if(l)return;let c=t.srcExtent||Y(i,e,s);if(c==null)return;const u=r.transform;u&&(c=u.inverseTransform(c)),t.srcExtent=c;const{x:h,y:m}=r.storageInfo.origin,p=Math.floor((c.xmin-h)/o.x+.1),y=Math.floor((m-c.ymax)/o.y+.1),x=Math.floor((c.xmax-h)/o.x-.1),d=Math.floor((m-c.ymin)/o.y-.1),f=c.width<.1*o.x?0:x-p+1,R=c.height<.1*o.y?0:d-y+1;t.pyramidLevel=a,t.pyramidResolution=o,t.srcWidth=f,t.srcHeight=R,t.ul={x:p,y}}_getRequestOptionsWithSliceId(i){return this.rasterInfo.multidimensionalInfo!=null&&i.sliceId==null&&(i={...i,sliceId:this.getSliceIndex(i.multidimensionalDefinition)}),i}_processIdentifyResult(i,t){const{srcLocation:r,position:e,pyramidLevel:n,useTransposedTile:s}=t,a=i.pixels[0].length/i.width/i.height;if(!(!i.mask||i.mask[e]))return{location:r,value:null};const{multidimensionalInfo:o}=this.rasterInfo;if(o==null||!s){const d=i.pixels.map(b=>b[e]),f={location:r,value:d,pyramidLevel:n},R=this._computeMagDirValues(d.map(b=>[b]));return R!=null&&R.length&&(f.magdirValue=R.map(b=>b[0])),f}let l=i.pixels.map(d=>d.slice(e*a,e*a+a)),c=this._computeMagDirValues(l);const{requestSomeSlices:u,identifyOptions:h}=t;let m=Oe(o,h.transposedVariableName);if(u){const d=We(m,h.multidimensionalDefinition,h.timeExtent);l=l.map(f=>d.map(R=>f[R])),c=c==null?void 0:c.map(f=>d.map(R=>f[R])),m=d.map(f=>m[f])}const p=i.noDataValues||this.rasterInfo.noDataValue,y={pixels:l,pixelType:i.pixelType};let x;return p!=null&&(xt(y,p),x=y.mask),{location:r,value:null,dataSeries:m.map((d,f)=>{const R={value:(x==null?void 0:x[f])===0?null:l.map(b=>b[f]),multidimensionalDefinition:d.multidimensionalDefinition.map(b=>new Se({...b,isSlice:!0}))};return c!=null&&c.length&&(R.magdirValue=[c[0][f],c[1][f]]),R}),pyramidLevel:n}}};function Pt(i,t,r){return Math.abs(i.x-t.x)<r&&Math.abs(i.y-t.y)<r}g([I()],v.prototype,"_rasterTileAlignmentInfo",void 0),g([I()],v.prototype,"_tileFetchQueue",void 0),g([I({readOnly:!0})],v.prototype,"_isGlobalWrappableSource",null),g([I({readOnly:!0})],v.prototype,"_hasNoneOrGCSShiftTransform",null),g([I()],v.prototype,"_openPromise",void 0),g([I()],v.prototype,"rasterJobHandler",null),g([I({readOnly:!0})],v.prototype,"rasterId",null),g([I(_e)],v.prototype,"url",null),g([I({type:String,json:{write:!0}})],v.prototype,"datasetName",void 0),g([I({type:String,json:{write:!0}})],v.prototype,"datasetFormat",void 0),g([I()],v.prototype,"hasUniqueSourceStorageInfo",void 0),g([I()],v.prototype,"rasterInfo",void 0),g([I()],v.prototype,"ioConfig",void 0),g([I()],v.prototype,"sourceJSON",void 0),v=g([ce("esri.layers.support.rasterDatasets.BaseRaster")],v);const Ft=40;let j=class extends v{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(i,t,r,e={}){var b,_;const{rasters:n,rasterIds:s}=this.primaryRasters;let a=!1;const{interpolation:o}=e,l=(b=this.rasterFunction.flatWebGLFunctionChain)==null?void 0:b.hasFocalFunction;!e.requestRawData&&l&&(a=n.length===1&&!e.skipRasterFunction,e={...e,interpolation:"bilinear",requestRawData:a});const c=n.map(w=>w.fetchPixels(i,t,r,e)),u=await Promise.all(c),h=u.map(w=>w.pixelBlock),m=a||e.requestRawData?u.map(w=>w.srcTilePixelSize):null;if(e.skipRasterFunction||h.every(w=>w==null))return u[0];const p=((_=u.find(w=>w.pixelBlock!=null))==null?void 0:_.extent)??i;let y=this.rasterJobHandler?await this.rasterJobHandler.process({extent:p,primaryPixelBlocks:h,primaryPixelSizes:m,primaryRasterIds:s}):this.rasterFunction.process({extent:p,primaryPixelBlocks:h,primaryPixelSizes:m,primaryRasterIds:s});const{transformGrid:x}=u[0];if(!a||y==null||x==null){const w=e.noClip?null:this.getClippingGeometry(p.spatialReference);return e.noClip||e.requestRawData||y==null||!w||(y=await le(y,p,w)),{...u[0],pixelBlock:y}}const d={rows:x.spacing[0],cols:x.spacing[1]};let f;this.rasterJobHandler?f=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[y],srcMosaicSize:{width:y.width,height:y.height},destDimension:{width:t,height:r},coefs:x.coefficients,sampleSpacing:d,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:o,alignmentInfo:void 0,blockWidths:null},e)).pixelBlock:f=ke(y,{width:t,height:r},x.coefficients,d,o);const R=e.noClip?null:this.getClippingGeometry(i.spatialReference);return e.noClip||e.requestRawData||f==null||R==null||(f=await le(f,i,R)),{extent:i,srcExtent:u[0].srcExtent,pixelBlock:f}}getClippingGeometry(i){const t=this._clippingGeometry.get("0");if(!i||!t)return t;const r=Ct(i);let e=this._clippingGeometry.get(r);return e!=null||(e=i.equals(t.spatialReference)?t:oe(t,i),this._clippingGeometry.set(r,e)),e}async _open(i){var c,u,h,m;const{rasterFunction:t}=this;t.isRoot=!0,(u=(c=this.primaryRasters)==null?void 0:c.rasters)!=null&&u.length?t.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=t.getPrimaryRasters(),this.rasterJobHandler&&((h=this.primaryRasters.rasters)==null||h.forEach(p=>p.rasterJobHandler=this.rasterJobHandler)));const{rasters:r,rasterIds:e}=this.primaryRasters,n=r.map(p=>p.rasterInfo?void 0:p.open(i));await Promise.all(n);const s=r.map(({rasterInfo:p})=>p),a=t.bind({rasterInfos:s,rasterIds:e});if(t.rawSourceRasterInfos=s,!a.success||s.length===0)throw new N("raster-function:open",`cannot bind the function: ${a.error??""}`);const o=t.functionName==="Table"?t:(m=t.functionArguments)==null?void 0:m.raster;(o==null?void 0:o.functionName)==="Table"&&(t.rasterInfo.attributeTable=$e.fromJSON(o.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const l=s[0];this.hasUniqueSourceStorageInfo=s.length===1||s.slice(1).every(p=>Bt(p,l)),this.set("sourceJSON",r[0].sourceJSON),this.set("rasterInfo",t.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){var i;return(i=this.rasterJobHandler)==null?void 0:i.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const i=this.rasterFunction.getClippingGeometries()[0];let t=i==null?void 0:i.clippingGeometry;if(t&&i.clippingType==="inside"){const{extent:r}=this.rasterInfo,e=await K(()=>import("./densifyOperator-CEhH7LYN.js").then(a=>a.d),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11])),n=await K(()=>import("./differenceOperator-D0FU99fK.js").then(a=>a.d),__vite__mapDeps([12,3,4,5,6,7,1,2,8,9,11]));let s=e.execute(ze.fromExtent(r),2*(r.width+r.height)/Ft);s=oe(s,t.spatialReference),t=n.execute(s,t)}this._clippingGeometry.clear(),t&&this._clippingGeometry.set("0",t)}};function Bt(i,t){const{storageInfo:r,pixelSize:e,spatialReference:n,extent:s}=i,{storageInfo:a,pixelSize:o,spatialReference:l,extent:c}=t;return e.x===o.x&&e.y===o.y&&n.equals(l)&&s.equals(c)&&r.blockHeight===a.blockHeight&&r.blockWidth===a.blockWidth&&r.maximumPyramidLevel===a.maximumPyramidLevel}function Ct(i){return String(i.wkid??i.wkt??i.wkt2)}g([I({type:String,json:{write:!0}})],j.prototype,"datasetFormat",void 0),g([I()],j.prototype,"tileType",void 0),g([I()],j.prototype,"rasterFunction",void 0),g([I()],j.prototype,"primaryRasters",void 0),j=g([ce("esri.layers.support.rasterDatasets.FunctionRaster")],j);const Re=1e3,Lt=i=>{let t=class extends i{constructor(...e){var n;super(...e),this._isConstructedFromFunctionRaster=!1,this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=V((n=e[0])==null?void 0:n.raster)}destroy(){this._shutdownJobHandler()}get fullExtent(){var e;return(e=this.serviceRasterInfo)==null?void 0:e.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){var n;((n=e==null?void 0:e.functionName)==null?void 0:n.toLowerCase())==="none"&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",Ie(e,re.getLogger(this)))}get renderer(){if(this.type!=="imagery-tile")return this.internalRenderer;const{activePresetRendererName:e,presetRenderers:n}=this;if(e){const s=n==null?void 0:n.find(({name:a})=>a===e);return s==null?void 0:s.renderer.clone()}return this.internalRenderer}set renderer(e){this.type==="imagery-tile"&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){e==null&&this.rasterFunction==null?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,n,s){var o,l;const a=(l=(o=n==null?void 0:n.layerDefinition)==null?void 0:o.drawingInfo)==null?void 0:l.renderer;return Ge(a,s)||void 0}async computeStatisticsHistograms(e,n){await this.load(n),e=se(je,e).clone();const{serviceRasterInfo:s}=this;if(s==null)throw new N("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:a}=e;if(a==null)throw new N("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let o=a;const{spatialReference:l}=s;if(!a.spatialReference.equals(l)){await ae();const d=a.type==="extent"?Y(a,l):oe(a,l);if(d==null)throw new N("imagery-tile-mixin:compute-statistics-histograms","geometry cannot be projected to the data source");o=d}const c=e.pixelSize??new C({x:s.pixelSize.x,y:s.pixelSize.y,spatialReference:l}),{extent:u,width:h,height:m}=gt(s,o,c),p=await this.fetchPixels(u,h,m,{...n,interpolation:"nearest"});if(p.pixelBlock==null)throw new N("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const y=await le(p.pixelBlock,u,o),x=this._rasterJobHandler;return x?x.computeStatisticsHistograms({pixelBlock:y},n):ct(y)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:n}=this.serviceRasterInfo??{};if(n==null)return e;const s=Ve({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:s,timeExtent:void 0}}async updateRasterFunction(){var e;return this.loaded&&this.type==="imagery-tile"&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=(e=this.rasterFunction)==null?void 0:e.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:e,symbolizer:n,renderer:s}=this;if(!e||!n||!s)return;const{rasterInfo:a}=this.raster,o=fe(a,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),l=o==null?void 0:o.name,c=me(a,l);return this._updateSymbolizer(n,s,l,c)}async applyRenderer(e,n,s){const a=e==null?void 0:e.pixelBlock;if(!(a!=null&&a.pixels&&a.pixels.length>0))return null;await this.updateRenderer();const o=this.bandIds??[],{pixelBlock:l}=await this._symbolize({pixelData:e,simpleStretchParams:n,bandIds:o,symbolizer:this.symbolizer},s);return l}getTileUrl(e,n,s){return this.raster.datasetFormat==="RasterTileServer"?`${this.url}/tile/${e}/${n}/${s}`:""}getCompatibleTileInfo(e,n,s=!1){if(!this.loaded||n==null)return null;if(s&&e.equals(this.spatialReference))return this.tileInfo;const a=Ne(e);return Z.create({size:256,spatialReference:e,origin:a?{x:a.origin[0],y:a.origin[1]}:{x:n.xmin,y:n.ymax}})}getCompatibleFullExtent(e){var n;return this.loaded?((n=this._compatibleFullExtent)!=null&&n.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,n,s,a={}){var l;if(r(this),a.requestAsImageElement){const c=this.getTileUrl(e,n,s);return be(c,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:a.signal}).then(u=>u.data)}const{serviceRasterInfo:o}=this;if(o.multidimensionalInfo!=null&&(a=this.normalizeRasterFetchOptions(a)).multidimensionalDefinition==null){const c=a.tileInfo||o.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(e,n,s,c),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),((l=this.renderer)==null?void 0:l.type)==="raster-shaded-relief"&&(a={...a,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,n,s,a)}async fetchPixels(e,n,s,a={}){return this.serviceRasterInfo.multidimensionalInfo!=null&&(a=this.normalizeRasterFetchOptions(a)).multidimensionalDefinition==null?{extent:e,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),n=Math.round(n),s=Math.round(s),this.raster.fetchPixels(e,n,s,a))}async getSamples(e,n){var c;if(await this.load(),(e=se(Ue,e).clone()).interpolation&&e.interpolation!=="nearest")throw new N("imagery-tile-mixin:get-samples","only nearest interpolation is currently supported");const s=(c=e.mosaicRule)==null?void 0:c.multidimensionalDefinition,a={...n,multidimensionalDefinition:s},o=(await this._getSampleLocations(e)).map(u=>this.identify(u,a).then(h=>(h.location=u,h))),l=(await Promise.all(o)).flatMap((u,h)=>this._convertRasterIdentifyResultToSample(u,h));return new Qe({samples:l})}async identify(e,n={}){var c,u,h;await this.load();const{raster:s,serviceRasterInfo:a}=this;if((a==null?void 0:a.multidimensionalInfo)!=null&&!(a.hasMultidimensionalTranspose&&!(!ve(n.multidimensionalDefinition)&&!n.transposedVariableName))&&(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition==null)return{location:e,value:null};const o=(c=this.multidimensionalSubset)==null?void 0:c.areaOfInterest;if(o&&!o.contains(e))throw new N("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");const l=(u=this.serviceRasterInfo)!=null&&u.storageInfo.isBsqTile&&((h=this.bandIds)!=null&&h.length)?this.bandIds:void 0;return s.identify(e,{...n,bandIds:l})}hasStandardTime(){var a,o,l;const e=(a=this.serviceRasterInfo)==null?void 0:a.multidimensionalInfo;if(e==null||((o=this.serviceRasterInfo)==null?void 0:o.dataType)!=="standard-time")return!1;const n=this.multidimensionalDefinition,s=(l=n==null?void 0:n[0])==null?void 0:l.variableName;return e.variables.some(c=>c.name===s&&(!(n!=null&&n[0].dimensionName)||c.dimensions.some(u=>u.name==="StdTime")))}getStandardTimeValue(e){return new Date(Xe(e)).toISOString()}getMultidimensionalSubsetVariables(e){var s;const n=e??((s=this.serviceRasterInfo)==null?void 0:s.multidimensionalInfo);return Ye(this.multidimensionalSubset,n)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=Ze(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&V(this.raster)&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}async _initJobHandler(){if(!this._rasterJobHandler)return super._initJobHandler().then(async()=>{if(!this._rasterJobHandler)return;r(this);const{raster:e}=this;e.rasterJobHandler=this._rasterJobHandler,V(e)&&e.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{})}_shutdownJobHandler(){super._shutdownJobHandler(),this.raster&&(this.raster.rasterJobHandler=null)}async _getSampleLocations(e){const{geometry:n}=e;if(n.type==="point")return[n];const{spatialReference:s,type:a}=n;if(a==="multipoint")return n.points.map(d=>new C({x:d[0],y:d[1],spatialReference:s}));if(a==="polyline"){let d=n;if(e.sampleCount||e.sampleDistance){const f=await K(()=>import("./densifyOperator-CEhH7LYN.js").then(w=>w.d),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11])),R=(await K(async()=>{const{execute:w}=await import("./lengthOperator-Dzm68w-M.js").then(z=>z.l);return{execute:w}},__vite__mapDeps([13,1,2,3,5,4,6,7,8,9,11]))).execute(n,{unit:"meters"}),b=Math.min(e.sampleCount||100,Re);let _=e.sampleDistance;_||(_=R/(b+(d.paths[0].length===2?1:0))),d=f.execute(n,_,{unit:"meters"})}return d.paths.flatMap(f=>f.map(R=>new C({x:R[0],y:R[1],spatialReference:s})))}const o=Math.min(e.sampleCount||100,Re),l=n.type==="extent",c=l?n:n.extent,u=Math.sqrt(c.width*c.height/o),h=c.height/u,m=c.width/u,{xmin:p,ymax:y}=c,x=[];for(let d=0;d<h;d++)for(let f=0;f<m;f++){const R=new C({x:p+(f+.5)*u,y:y-(d+.5)*u,spatialReference:s});(l||n.contains(R))&&x.push(R)}return x}_configDefaultInterpolation(){var e;if(this.interpolation==null){r(this);const{raster:n}=this,s=Ke(n.rasterInfo,n.tileType,(e=this.sourceJSON)==null?void 0:e.defaultResamplingMethod);this._set("interpolation",s)}}_configDefaultRenderer(e="no"){var h,m,p;r(this);const{rasterInfo:n}=this.raster,s=fe(n,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),a=s==null?void 0:s.name,o=et({variableName:a,rasterFunctionName:(h=this.rasterFunction)==null?void 0:h.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&n.bandCount>1&&(this.bandIds=(o==null?void 0:o.bandIds)??tt(n)),!this.renderer||e==="override"){const y=it(this.raster),x=(o==null?void 0:o.renderer)??de(n,{bandIds:this.bandIds,variableName:a,rasterFunctionColorRamp:y}),d=n.statistics,f=d&&d.length>0?d[0]:null,R=(f==null?void 0:f.max)??0,b=(f==null?void 0:f.min)??0;this.raster.datasetFormat==="WCSServer"&&x.type==="raster-stretch"&&(R>1e24||b<-1e24)&&(x.dynamicRangeAdjustment=!0,x.customStatistics=null,x.stretchType==="none"&&(x.stretchType="min-max")),this.renderer=x}const l=nt({...this.renderer.toJSON(),variableName:a}),c=me(n,a);this.symbolizer?(this.symbolizer.rendererJSON=l,this.symbolizer.rasterInfo=c):this.symbolizer=new ut({rendererJSON:l,rasterInfo:c});const u=this.symbolizer.bind();if(u.success){if(e==="auto"){const{colormap:y}=this.raster.rasterInfo,x=this.renderer;if(y!=null&&x.type==="raster-colormap"){const d=de(this.raster.rasterInfo);JSON.stringify(d)!==JSON.stringify(x)&&this._configDefaultRenderer("override")}else if(x.type==="raster-stretch"){const d=(m=this.bandIds)==null?void 0:m.length,f=(p=x.customStatistics)==null?void 0:p.length;!x.dynamicRangeAdjustment&&f&&d&&f!==d&&this._configDefaultRenderer("override")}}}else re.getLogger(this).warn("imagery-tile-mixin",u.error||"The given renderer is not supported by the layer."),e==="auto"&&this._configDefaultRenderer("override")}async _updateRasterFunction(){var u;if(this._isConstructedFromFunctionRaster&&V(this.raster)){const h=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&h&&this._set("rasterFunction",he.fromJSON(h)))}let e,n=this.raster,s=!1;V(n)?(e=n.primaryRasters.rasters,n=e[0],s=!0):e=[n];const{rasterFunction:a}=this;if(a){const h={raster:n};e.length>1&&e.forEach(y=>h[y.url]=y);const m=Rt(((u=a.functionDefinition)==null?void 0:u.toJSON())??a.toJSON(),h),p=new j({rasterFunction:m});p.rasterJobHandler=this._rasterJobHandler,await p.open(),this.raster=p}else this.raster=n,await n.open();if(this._cachedRendererJson=void 0,!s&&!a)return;const{bandIds:o}=this,{bandCount:l}=this.raster.rasterInfo,c=o!=null&&o.length?o.some(h=>h>=l):l>=3;o&&(c||this.renderer&&this.renderer.type!=="raster-stretch")&&this._set("bandIds",null),this._configDefaultRenderer("auto")}_convertRasterIdentifyResultToSample(e,n){var c;const{rasterInfo:s}=this.raster,a=s.storageInfo.pyramidScalingFactor**(e.pyramidLevel??0),o=(s.pixelSize.x+s.pixelSize.y)/2*a;if(!((c=e.dataSeries)!=null&&c.length))return[new pe({location:e.location,pixelValue:e.value,locationId:n,resolution:o})];const l=[];return e.dataSeries.forEach(({value:u,multidimensionalDefinition:h},m)=>{const p={Variables:h[0].variableName,Dimensions:h.flatMap(({dimensionName:x})=>x).join(",")};for(const{dimensionName:x,values:d}of h){p[x]=Array.isArray(d[0])?d[0][0]:d[0];const f=d[d.length-1];p[`${x}_Max`]=Array.isArray(f)?f[f.length-1]:f}const y=new pe({location:e.location,pixelValue:u,rasterId:m,locationId:n,resolution:o,attributes:p});l.push(y)}),l}};function r(e){if(!e.raster||!e.serviceRasterInfo)throw new N("imagery-tile","no raster")}return g([I({clonable:!1})],t.prototype,"_cachedRasterFunctionJson",void 0),g([I({clonable:!1})],t.prototype,"_compatibleFullExtent",void 0),g([I({clonable:!1})],t.prototype,"_isConstructedFromFunctionRaster",void 0),g([I({clonable:!1})],t.prototype,"_rasterFunctionUpdatePromise",void 0),g([I({type:[Me],json:{write:{overridePolicy(){var e;return{enabled:!this.loaded||this.raster.tileType==="Raster"||((e=this.bandIds)==null?void 0:e.join(","))!=="0,1,2"}}}}})],t.prototype,"bandIds",void 0),g([I({json:{origins:{service:{read:{source:"copyrightText"}}}}})],t.prototype,"copyright",void 0),g([I({json:{read:!1}})],t.prototype,"fullExtent",null),g([I({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.interpolation!=="bilinear"}}}}}),He(ht)],t.prototype,"interpolation",void 0),g([I()],t.prototype,"ioConfig",void 0),g([I({type:[Se],json:{write:!0}})],t.prototype,"multidimensionalDefinition",null),g([I({type:Le,json:{write:!0}})],t.prototype,"multidimensionalSubset",void 0),g([I()],t.prototype,"raster",void 0),g([I({type:he})],t.prototype,"rasterFunction",null),g([I()],t.prototype,"serviceRasterInfo",void 0),g([I()],t.prototype,"sourceJSON",void 0),g([I({readOnly:!0,type:we,json:{read:!1}})],t.prototype,"spatialReference",void 0),g([I({type:Z})],t.prototype,"tileInfo",void 0),g([I(_e)],t.prototype,"url",null),g([I()],t.prototype,"renderer",null),g([I({types:qe,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){var n;const e=((n=this.renderer)==null?void 0:n.type)==="raster-stretch"&&this.renderer.stretchType==="none"&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType==="Raster"||!e}}},origins:{"web-scene":{types:Ae,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&e.type!=="vector-field"&&e.type!=="flow"})}}}}})],t.prototype,"internalRenderer",null),g([Je("internalRenderer")],t.prototype,"readRenderer",null),g([I({clonable:!1})],t.prototype,"symbolizer",void 0),t=g([ce("esri.layers.mixins.ImageryTileMixin")],t),t};function ee(i,t){if(!i||!t)return[];let r=t;t.includes("/")?(r=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const e=[];if(t){const s=ee(i,r);for(let a=0;a<s.length;a++)ee(s[a],t).forEach(o=>e.push(o));return e}const n=i.getElementsByTagNameNS("*",r);if(!n||n.length===0)return[];for(let s=0;s<n.length;s++)e.push(n[s]||n.item(s));return e}function Te(i,t){if(!i||!t)return null;let r=t;t.includes("/")?(r=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const e=ee(i,r);return e.length>0?t?Te(e[0],t):e[0]:null}function Pe(i,t=null){const r=t?Te(i,t):i;let e;return r?(e=r.textContent||r.nodeValue,e?e.trim():null):null}function Dt(i,t){const r=ee(i,t),e=[];let n;for(let s=0;s<r.length;s++)n=r[s].textContent||r[s].nodeValue,n&&(n=n.trim(),n!==""&&e.push(n));return e}function At(i,t=null){const r=Pe(i,t);return(r==null?void 0:r.split(" ").map(e=>Number(e)))??[]}function qt(i,t){return Dt(i,t).map(r=>Number(r))}function Gt(i,t){const r=Pe(i,t);return Number(r)}function jt(i,t){var n;const r=(n=i==null?void 0:i.nodeName)==null?void 0:n.toLowerCase(),e=t.toLowerCase();return r.slice(r.lastIndexOf(":")+1)===e}function Vt(i){return i.nodeName.slice(i.nodeName.lastIndexOf(":")+1)}export{v as $,Lt as X,Vt as c,Te as e,jt as i,Dt as l,j as m,ee as n,Gt as o,At as r,Pe as t,qt as u};
